options {
    STATIC = false;
    LOOKAHEAD = 2;
}

PARSER_BEGIN(WAT)
package io.github.eutro.jwasm.sexp.gen;

import io.github.eutro.jwasm.Limits;
import io.github.eutro.jwasm.Opcodes;
import io.github.eutro.jwasm.tree.*;
import io.github.eutro.jwasm.ByteList;
import io.github.eutro.jwasm.sexp.Script;
import java.util.*;

public class WAT {
}
PARSER_END(WAT)

TOKEN :
{
  < #SIGN : ["+","-"] >
| < #DIGIT : ["0"-"9"] >
| < #HEXDIGIT : ["0"-"9","a"-"f","A"-"F"] >
| < #NUM : <DIGIT> ("_" <DIGIT>)* >
| < #HEXNUM : <HEXDIGIT> ("_" <HEXDIGIT>)* >
| < #LETTER : ["a"-"z","A"-"Z"] >
| < #SYMBOL : ["+","-","*","/","\\","^","~","=","<",">","!","?","@","#","$","%","&","|",":","`",".","\""] >
| < #ESCAPE : ["n","r","t","\\","\'","\""] >
| < #CHARACTER : ~["\"","\\","\u0000"-"\u001f","\u007f"-"\u00ff"]
  | "\\" <ESCAPE>
  | "\\" <HEXDIGIT> <HEXDIGIT>
  | "\\u{" <HEXNUM> "}" >
| < NAT : <NUM> | "0x" <HEXNUM> >
| < INT : <SIGN> <NAT> >
| < #FRAC : <NUM> >
| < #HEXFRAC : <HEXNUM> >
| < FLOAT :
    (<SIGN>)? <NUM> "." (<FRAC>)?
  | (<SIGN>)? <NUM> ("." (<FRAC>)?)? ("e" | "E") (<SIGN>)? <NUM>
  | (<SIGN>)? "0x" <HEXNUM> "." (<HEXFRAC>)?
  | (<SIGN>)? "0x" <HEXNUM> ("." (<HEXFRAC>)?)? ("p" | "P") (<SIGN>)? <NUM>
  | (<SIGN>)? "inf"
  | (<SIGN>)? "nan"
  | (<SIGN>)? "nan:" "0x" <HEXNUM> >
| < STRING : "\"" (<CHARACTER>)* "\"" >
| < #IDCHAR : <LETTER> | <DIGIT> | "_" | <SYMBOL> >
| < #NAME : (<IDCHAR>)+ >
| < ID : "$" <NAME> >
| < OFFSET_EQ_NAT : "offset=" <NAT> >
| < ALIGN_EQ_NAT : "align=" <NAT> >
// | < KEYWORD : ["a"-"z"] (<LETTER> | <DIGIT> | "_" | "." | ":")+ >
// | < RESERVED : (<IDCHAR> | <STRING>)+ | "," | ";" | "[" | "]" | "{" | "}" >
// | < #IXX : "i" ("32" | "64") >
// | < #FXX : "f" ("32" | "64") >
// | < #NXX : <IXX> | <FXX> >
// | < #VXXX : "v128" >
// | < #MIXX : "i" ("8" | "16" | "32" | "64") >
// | < #MFXX : "f" ("32" | "64") >
// | < #SIGNED : "s" | "u" >
// | < #MEM_SIZE : "8" | "16" | "32" >
// | < #V128_INT_SHAPE : "i8x16" | "i16x8" | "i32x4" | "i64x2" >
// | < #V128_FLOAT_SHAPE : "f32x4" | "f64x2" >
// | < #V128_SHAPE : <V128_INT_SHAPE> | <V128_FLOAT_SHAPE> >
}

TOKEN_MGR_DECLS :
{
  // I <3 Java
  private static RuntimeException rethrowUnchecked(Throwable t) {
    rethrowGeneric(t);
    return null;
  }

  @SuppressWarnings("unchecked")
  private static <T extends Throwable> void rethrowGeneric(Throwable t) throws T {
    throw (T) t;
  }
}

SKIP : {
  " " | "\t" | "\n"
| < LINECOMMENT : ";;" (~["\n"])* >
| "(;" {
  int depth = 1;
  try {
    while (depth > 0) {
      char c = input_stream.readChar();
      if (c == '(' && input_stream.readChar() == ';') {
        depth++;
      } else if (c == ';' && input_stream.readChar() == ')') {
        depth--;
      }
    }
  } catch (java.io.IOException e) {
    throw rethrowUnchecked(e); // <3
  }
}
}

private String name() : { Token s; }
{ s=<STRING> { return s.toString(); } }

private String stringList(StringBuilder sb) : { Token t; }
{ (t=<STRING> { sb.append(t); })* { return sb.toString(); } }

private byte refKind() : {}
{ "func" { return Opcodes.REF_FUNC; }
// | "extern" { return ??; }
}

private byte refType() : {}
{ "funcref" { return Opcodes.FUNCREF; }
| "externref" { return Opcodes.EXTERNREF; } }

private byte numType() : {}
{ "i32" { return Opcodes.I32; }
| "i64" { return Opcodes.I64; }
| "f32" { return Opcodes.F32; }
| "f64" { return Opcodes.F64; } }

private byte valueType() : { byte ty; }
{ ty=numType() { return ty; }
// ty=vecType() { return ??; }
| ty=refType() { return ty; } }

private List<Byte> valueTypeList(List<Byte> l) : { byte ty; }
{ (ty=valueType() { l.add(ty); })* { return l; } }


private GlobalTypeNode globalType() : { byte ty; }
{ ty=valueType() { return new GlobalTypeNode(Opcodes.MUT_CONST, ty); }
| "(" "mut" ty=valueType() ")" { return new GlobalTypeNode(Opcodes.MUT_VAR, ty); } }

private TypeNode defType() : { TypeNode ty; }
{ "(" "func" ty=funcType() ")" { return ty; } }

private byte[] unwrapBytes(List<Byte> bs) : {}
{ { byte[] rbs = new byte[bs.size()]; int i = 0; for (byte b : bs) rbs[i++] = b; return rbs; } }

private void funcType1(List<Byte> params, List<Byte> rets) : { byte ty; }
{ ("(" "param"
     (valueTypeList(params) |
      /*FIXME bind*/var() ty=valueType() { params.add(ty); })
   ")")*
  funcTypeResult(rets) }

private TypeNode funcType() : { List<Byte> params = new ArrayList<Byte>(), rets = new ArrayList<Byte>(); }
{ funcType1(params, rets) { return new TypeNode(unwrapBytes(params), unwrapBytes(rets)); } }

private List<Byte> funcTypeResult(List<Byte> bs) : {}
{ ("(" "result" valueTypeList(bs) ")")* { return bs; } }

private TableNode tableType() : { Limits ls; byte ty; }
{ ls=limits() ty=refType() { return new TableNode(ls, ty); } }

private MemoryNode memType() : { Limits ls; }
{ ls=limits() { return new MemoryNode(ls); } }

private int nat32(String s) : {}
{ { if (s.startsWith("0x")) { return Integer.parseInt(s.substring(2), 16); }
    else { return Integer.parseInt(s); } } }

private int int32(String s) : {}
{ { int n = nat32(s.substring(1)); return s.startsWith("-") ? -n : n; } }

private Limits limits() : { Token min, max = null; }
{ min=<NAT> [max=<NAT>] { new Limits(nat32(min.image), max == null ? null : nat32(max.image)); }}

private TypeNode typeUse() : { TypeNode ty; }
{ "(" "type" ty=var() ")" { return ty; } }

private Number num() : { Token t; }
{ t=<NAT> { return nat32(t.image); }
| t=<INT> { return int32(t.image); }
| t=<FLOAT> { throw new RuntimeException("TODO"); } }

private List<Number> numList(List<Number> ls) : { Number n; }
{ (n=num() { ls.add(n); })* { return ls; } }

private TypeNode var() : { Token t; }
{ t=<NAT> { return null; }
// TODO
}










public ModuleNode module_() : {}
{ "(" "module" ")" <EOF> { return new ModuleNode(); } }

public ModuleNode inlineModule() : {}
{ "module_fields" <EOF> { return new ModuleNode(); } }

public ModuleNode module1() : { ModuleNode m; }
{ m = module_() <EOF> { return m; }
| m = inlineModule() <EOF> { return m; } }

private Script.Command action() : {}
{ <EOF> }

private Script.Command cmd() : { Script.Command cmd; }
{ action() }

private void cmdList(Script s) : { Script.Command c; }
{ (c=cmd() { s.commands.add(c); })* }

public Script script1() : { Script s = new Script(); }
{ <EOF> { return s; } }

public Script script() : { Script s = new Script(); ModuleNode m; }
{ m=inlineModule() { s.commands.add(new Script.Command.Module(m)); return s; } }
